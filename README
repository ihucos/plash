# we must initilaize the storage directory
$ plash-init

# build a simple image
$ plash-build --image alpine --run 'touch /file'
[0%|10%|20%|30%|40%|50%|60%|70%|80%|90%|100%]
extracting...
--> touch /file
--:
2

# second build is cached
$ plash-build --image alpine --run 'touch /file'
2

# run something inside a container
$ plash-run 2 ls /file
/file

# layering is explicit
$ plash-build --image alpine --run 'touch /file' --layer --run 'touch /file2'
--> touch /file2
--:
3

# delete a container
$ plash-rm 3

# build and run in one command
$ plash-run --image alpine --run 'touch /file' -- ls /file
/file

# you can easily mount, execute a command on the filesystem, then unmount.
$ plash-with-mount --image alpine -- ls
bin  etc   lib	  mnt	root  sbin  sys  usr
dev  home  media  proc	run   srv   tmp  var
$ plash-with-mount -i alpine -- chroot . /bin/sh
/ # exit

# plash actually includes some configuration management 
$ plash-run --image alpine --apk git -- git --version
--> apk update
fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/main/x86_64/APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/community/x86_64/APKINDEX.tar.gz
v3.7.0-61-g66a2eadbb3 [http://dl-cdn.alpinelinux.org/alpine/v3.7/main]
v3.7.0-58-g26701b74f8 [http://dl-cdn.alpinelinux.org/alpine/v3.7/community]
OK: 9044 distinct packages available
--> apk add git
(1/6) Installing ca-certificates (20171114-r0)
(2/6) Installing libssh2 (1.8.0-r2)
(3/6) Installing libcurl (7.57.0-r0)
(4/6) Installing expat (2.2.5-r0)
(5/6) Installing pcre2 (10.30-r0)
(6/6) Installing git (2.15.0-r1)
Executing busybox-1.27.2-r8.trigger
Executing ca-certificates-20171114-r0.trigger
OK: 21 MiB in 22 packages
--:
git version 2.15.0

$ echo '#!/usr/bin/env plash-exec
> # plash-exec: exec=fzf
> --image
> alpine
> --apk
> wget
> --run
> cd $(mktemp -d)
> wget -q https://github.com/junegunn/fzf-bin/releases/download/0.17.3/fzf-0.<m/junegunn/fzf-bin/releases/download/0.17.3/fzf-0.1                         7.3-linux_amd64.tgz
> tar xvzf *.tgz
> cp fzf /usr/local/bin/fzf' > /tmp/fzf

$ chmod +x /tmp/fzf
$ /tmp/fzf --version
--> apk update
fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/main/x86_64/APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/community/x86_64/APKINDEX.tar.gz
v3.7.0-61-g66a2eadbb3 [http://dl-cdn.alpinelinux.org/alpine/v3.7/main]
v3.7.0-58-g26701b74f8 [http://dl-cdn.alpinelinux.org/alpine/v3.7/community]
OK: 9044 distinct packages available
--> apk add wget
(1/1) Installing wget (1.19.2-r1)
Executing busybox-1.27.2-r8.trigger
OK: 7 MiB in 17 packages
--> mktemp -d
--> cd /tmp/tmp.jIGiEm
--> wget -q https://github.com/junegunn/fzf-bin/releases/download/0.17.3/fzf-0.17.3-linux_amd64.tgz
--> tar xvzf fzf-0.17.3-linux_amd64.tgz
fzf
--> cp fzf /usr/local/bin/fzf
--:
0.17.3 (390b496)

$ exit
exit


########
## DRAFT
#######


Plash
is a container build an runtime system.

install
pip install blah

Documentation
This README
reference: link.
More being written.


Why Plash?

- Runs anywhere.
Plash's only requiremenets is python3, a linux kernel (>= 3.18) and the mount
binary. It does not need an extra daemon and can be used in infrastructure not
meant to run containers like ci environemnts or exotic distributions. Running it inside docker is considered a valid use case. If you have linux and
root, it should run there.

- Flexibility
You can mount a container, add a layer on top of a container, run
a container with runc, use images from the docker world, export an image to
docker, create a container from a shell session, and much more.

- Its just processes.
Plash containers are processes exactly like you know them.
They can be listed with ps, `kill`ed, you can filter for stderr or pipe to
stdin, manage them in groups with supervisord or runit or access your home directory. Only parts of the
filesystem are isolated. If you need more isolation, use another tool just for
that or run containers "traditionally" with plash-runc.

- Plashfiles
Plashfiles are executable. At buildtime the home folder is mounted, so you can have ...bla

Example session:
{{ EXAMPLE_HERE }}


Security
Plash's default container runtime does come with a security concept.  That is
figuratively speaking to not barricade anything with tape. It does not try to
invent any new security layer but to only rely on traditional UNIX security
mechanisms. Inside a container a user is what he was outside of it. As far as
the kernel cares the only difference between a container and a "normal" process
is that the container is chrooted. Access rights established outside of the
container should still be valid inside the container. So in fact to install
software with a package manager inside a container you probably need root, but
to run it not. It can be seen as a one to one mappping between host and
container.  There is some fine print: root access is needed for setup. In the
future the plan is to use suid binaries to archive this. In the moment sudo is
used used for that. To allow a user to use plash put this is the suoders file
`joe ALL=NOPASSWD: /usr/local/bin/plash-run`. Since this software
is still not "finished" this should currenlty be considered totally unsafe.

Plashfiles

Philosophy
Plash thrives not to be more than a usefull tool. There is no monetization
strategy, bundling or closed source. It plays well with other software in the
container ecosystem. Plash and its internal architecture tries to honor the "Do
One Thing and Do It Well" UNIX philosphy. This software tries to not "oversell" its
abstraction layer, which is containerization of processes. Containerization and
isolation are seen as two different tasks, but as a flexible tool this software
does not enforce any specific why of using it.  Plash tries to be very
maintainable and still run without any changes in 5 or 10 years.  Plash also
tries to cover less complicated use cases for containers, like letting a user
quickly user software from another distribution.  This software has tries to be
in any aspect to be lightweight.  Altough plash can also be seen as a framework
that is a great starting point for experimentation with containers its long term golas are stability, and
backwards compability (something that is not established yet).

FAQ
