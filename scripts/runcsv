#!/usr/bin/env python3

import sys, csv, subprocess, tempfile
from fnmatch import fnmatch

try:
    csvfile = sys.argv[1]
except IndexError:
    print("usage: runcsv CSVFILE")
    sys.exit(1)


ERR_TEMPL = """runcsv error - unexpected output
expanded: {expanded}
reality:  {reality}"""


PLASH_DATA = subprocess.check_output(["plash", "data"]).decode().strip("\n")


# state for variable format expansion logic
varstate = {"stderr": [], stdout=[], exit=[]}

class NamedVar:
    def __init__(self, create):
        self.state = {}
        self.create = create

    def __format__(self, format_spec=""):
        if not format_spec in self.state:
            self.state[format_spec] = self.create()
        return self.state[format_spec]


template_vars = {
    "TMPDIR": NamedVar(tempfile.mkdtemp),
    "TMPFILE": NamedVar(tempfile.mktemp),
    "PLASH_DATA": PLASH_DATA,
}

# tokenize csv
tokens = []
with open(csvfile) as file_obj:
    for line_vals in csv.reader(file_obj, quotechar="`"):
        if line_vals:
            base_entry = [None, "", "", "0"]
            for counter, arg in enumerate(line_vals):
                base_entry[counter] = arg
            tokens.append(base_entry)

for cmd_arg, stdout_arg, stderr_arg, exit_code in tokens:
    stdout = stdout_arg.format(**template_vars)
    stderr = stdout_arg.format(**template_vars)
    cmd = cmd_arg.format(**template_vars)

    # magic
    if stdout:
        stdout += "\n"
    if stderr:
        stderr += "\n"

    p = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    if (
        not fnmatch(p.stdout.decode(), stdout)
        or not fnmatch(p.stderr.decode(), stderr)
        or not fnmatch(str(p.returncode), exit_code)
    ):
        print(
            ERR_TEMPL.format(
                expected=','.join([cmd_arg, stdout_arg, stderr_arg, exit_code]),
                expanded=[cmd, stdout, stderr, exit_code],
                reality=[cmd, p.stdout.decode(), p.stderr.decode(), p.returncode],
            ),
            file=sys.stderr,
        )
        sys.exit(1)
