#!/usr/bin/env python3
"""

This executes commands specified in a csv and checks if their stdout, stderr
and exit code matches the values also specified in the csv.

This is not a general purpose script but a pragmatic collection of features
that seem helpful to test plash.
"""

import sys, csv, subprocess, tempfile, os
from fnmatch import fnmatch

try:
    csvfiles = sys.argv[1:]
except IndexError:
    print("usage: runcsv CSVFILE")
    sys.exit(1)

ERR_TEMPL = """{file}: unexpected stderr, stdout or exit
expanded: {expanded}
reality:  {reality}"""


PLASH_DATA = subprocess.check_output(["plash", "data"]).decode().strip("\n")

class NamedVar:
    def __init__(self, create):
        self.state = {}
        self.create = create

    def __format__(self, format_spec=""):
        if not format_spec in self.state:
            self.state[format_spec] = self.create()
        print(self.create)
        print(self.state)
        return self.state[format_spec]

class StackVar:
    def __init__(self):
        self.list = []
    def __format__(self, format_spec="0"):
        return self.list[int(format_spec)]
    def put(self, arg):
        self.list.append(arg)

class NextContainerIdVar:
    def __format__(self, format_spec=0):
        id_counter_path = os.path.join(PLASH_DATA, 'id_counter')
        return str(os.path.getsize(id_counter_path) + 1)


def create_template_vars():
    return {
        "TMPDIR": NamedVar(tempfile.mkdtemp),
        "TMPFILE": NamedVar(tempfile.mkstemp),
        "PLASH_DATA": PLASH_DATA,
        'STDERR': StackVar(),
        'STDOUT': StackVar(),
        'ID': NextContainerIdVar()
    }

# tokenize csv
for csvfile in csvfiles:

    tokens = []
    template_vars = create_template_vars()
    print()
    print(csvfile)
    with open(csvfile) as file_obj:
        for line_vals in csv.reader(file_obj, quotechar="`"):
            if line_vals:
                base_entry = [None, "", "", "0"]
                for counter, arg in enumerate(line_vals):
                    base_entry[counter] = arg
                tokens.append(base_entry)
    
    for cmd_arg, stdout_arg, stderr_arg, exit_code in tokens:
        stdout = stdout_arg.format(**template_vars)
        stderr = stderr_arg.format(**template_vars)
        cmd = cmd_arg.format(**template_vars)

        # that command is "special"
        if cmd.split()[0] == 'cd':
            os.chdir(cmd.split()[1])
            continue
    
        # magic
        if stdout:
            stdout += "\n"
        if stderr:
            stderr += "\n"
    
        p = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    
        child_stdout = p.stdout.decode()
        child_stderr = p.stderr.decode()
        child_exit = str(p.returncode)
    
        template_vars['STDOUT'].put(child_stdout)
        template_vars['STDERR'].put(child_stderr)
    
        #print([cmd, child_stdout, child_stderr, child_exit])
        if (
            not fnmatch(child_stdout, stdout)
            or not fnmatch(child_stderr, stderr)
            or not fnmatch(child_exit, exit_code)
        ):
            print(
                ERR_TEMPL.format(
                    file=csvfile,
                    expanded=[cmd, stdout, stderr, exit_code],
                    reality=[cmd, child_stdout, child_stderr, child_exit]
                ),
                file=sys.stderr,
            )
            sys.exit(1)
