#!/usr/bin/env python3
#
# usage: plash runopts [ -b BIND ] [ -n ] [ -c CHANGES ] CONTAINER [ CMD1 [ CMD2 ... ] ]
# Run a container with extra options

import argparse
import os
import re
import sys
from subprocess import CalledProcessError, check_call

import tempfile
from plash.unshare import unshare_if_root, unshare_if_user
from plash.utils import (assert_initialized, catch_and_die, die,
                         get_default_shell, handle_help_flag, mkdtemp)

DEFAULT_BIND = [
    '/tmp', '/home', '/root', '/etc/resolv.conf', '/sys', '/dev', '/proc'
]
LOGIN_DEFS_RE = re.compile(r'^\s*ENV_PATH\s+(?:PATH=){0,1}(.*?)\s*$', re.MULTILINE)
FALLBACK_PATH = '/bin:/usr/bin'

handle_help_flag()
assert_initialized()

parser = argparse.ArgumentParser(add_help=False)
parser.add_argument('container')
parser.add_argument('cmd', nargs='*')
parser.add_argument('-b', '--bind', action='append')
parser.add_argument('-n', '--no-default-binds', action='store_true')
parser.add_argument('-c', '--changes')
args = parser.parse_args()

requested_mounts = []
if not args.no_default_binds:
    requested_mounts.extend(DEFAULT_BIND)
requested_mounts.extend(args.bind or [])

mountpoint = tempfile.mkdtemp(dir='/var/tmp', prefix='plash-mountpoint-')

original_uid = os.getuid()
unshare_if_root()
unshare_if_user()

# mount container filesystem
if args.changes:
    changesdir = args.changes
else:
    changesdir = mkdtemp()
with catch_and_die([CalledProcessError], silent=True):
    try:
        check_call(['plash-mount', args.container, mountpoint, changesdir] )
    except CalledProcessError:
        if original_uid:
            print('plash: maybe your kernel has no FUSE user namespace support (>= 4.18)', file=sys.stderr)
        raise

# mount /proc and so on
for mount in requested_mounts:
    check_call([
        'mount', '--rbind', mount,
        os.path.join(mountpoint, mount.lstrip('/'))
    ])

# setup chroot and exec
pwd_at_start = os.getcwd()

# I had problems opening the files after the chroot (LookupError: unknown encoding: ascii)
default_root_shell = get_default_shell(os.path.join(mountpoint, 'etc/passwd'))

# read PATH from /etc/login.defs if available
try:
    with open(os.path.join(mountpoint, 'etc/login.defs')) as f:
        match = LOGIN_DEFS_RE.findall(f.read())
except FileNotFoundError:
    match = None
os.environ['PATH'] = match[-1] if match else FALLBACK_PATH

os.chroot(mountpoint)
try:
    os.chdir(pwd_at_start)
except (ValueError, OSError):
    os.chdir('/')
if not args.cmd:
    cmd = [default_root_shell]
else:
    cmd = args.cmd

with catch_and_die([OSError]):
    try:
        os.execlp(cmd[0], *cmd)
    except FileNotFoundError:
        sys.stderr.write('{}: command not found\n'.format(cmd[0]))
        sys.exit(127)
