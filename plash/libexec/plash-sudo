#!/bin/sh
#
# usage: plash sudo [CMD1 [CMD2 ..]]
#
# Setup a Linux user namespace. Then run the specified commands there. The
# default command is the default user shell.
#
# This is useful to access files written to disk by a container, when they
# where written by a non-root user (from the containers perspective). It can
# also be used as a general purpose utility to "fake" root access.

set -eu


username=$(id -un)
getuid=$(id -u)
if [ -f "/etc/subuid" ]; then
  while IFS=: read -r query uidstart uidcount; do
  [ "$query" = "$getuid" ]   && break
  [ "$query" = "$username" ] && break
  done <"/etc/subuid"
fi

groupname=$(id -un)
getgid=$(id -u)
if [ -f "/etc/subgid" ]; then
  while
    IFS=: read -r query gidstart gidcount
    [ "$query" != "$getgid" ]
    [ "$query" != "$groupname" ];
  do :; done <"/etc/subgid"
fi

#if not subgid and no subuid or no newuidmap installed
#exec unshare --mount --user --map-root -- "$@"


# create a fifo
tmpdir=$(mktemp -d)
fifo="$tmpdir"/fifo
mkfifo "$fifo"

# fork off and attempt mapping
child(){
  read -r pid < "$fifo"
  newuidmap "$pid" 0 "$getuid" 1 1 "$uidstart" "$uidcount"
  newgidmap "$pid" 0 "$getgid" 1 1 "$gidstart" "$gidcount"
  echo ok > "$fifo"
}
child &

# enter new user and mount namespace
exec unshare --user --mount sh -euc '
echo $$ > '"$fifo"'
eval "read -r status < '"$fifo"'" 2> /dev/null
if [ $# = 0 ]; then
  default_shell=$(getent passwd '"$username"' | cut -d: -f 7)
  exec "$default_shell"
else
  exec "$@"
fi
' -- "$@"
