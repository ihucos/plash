#!/usr/bin/env python
# vim: set filetype=python:
import atexit
import errno
import os
import shutil
import subprocess
import sys
from os.path import join
from subprocess import (DEVNULL, CalledProcessError, Popen, check_call,
                        check_output)
from tempfile import mkdtemp

from plash.utils import catch_and_die, die, hashstr, info

PLASH_DATA = os.environ.get('PLASH_DATA', '/var/lib/plash')

container = sys.argv[1]
cmd = sys.stdin.read()
quiet = False

try:
    node_path = check_output(['plash.nodepath', container]).decode().strip('\n')
except CalledProcessError:
    sys.exit(1)

new_container= hashstr(b':'.join([container.encode(), cmd.encode()]))
final_child_dst = join(join(PLASH_DATA, 'builds'), node_path, 'children', new_container)
try:
    check_output(['plash.nodepath', new_container], stderr=DEVNULL)
except CalledProcessError:
    pass
else:
    info('From cache')
    # its already cached
    print(new_container)
    sys.exit(0)


new_child = mkdtemp(dir=join(PLASH_DATA, 'tmp'))
mountpoint = mkdtemp(dir=join(PLASH_DATA, 'tmp'))
new_layer = join(new_child, 'payload')
os.mkdir(new_layer)
os.mkdir(join(new_child, 'children'))

def preexec_fn():
    os.close(
        0
    )  # close stdin for more reproducible builds - if that does not work well, there is another way

out = 2
p = subprocess.Popen(['plash.run', container, '--upperdir', new_layer, 'sh', '-cxe', cmd], stderr=out, stdout=out, preexec_fn=preexec_fn)
exit = p.wait()

if exit != 0:
    atexit.register(lambda: shutil.rmtree(new_child))
    die("build returned exit status {}".format(exit))

try:
    os.symlink(final_child_dst, join(PLASH_DATA, 'links', new_container))
except FileExistsError:
    pass

try:
    os.rename(new_child, final_child_dst)
except OSError as exc:
    if exc.errno == errno.ENOTEMPTY:
        info('container id or layer appeared while building, not replacing it'.format(new_container))
    else:
        raise

print(new_container)
