#!/usr/bin/env python3
# vim: set filetype=python:

# USAGE:plash run container [--workdir VALUE] [--upperdir VALUE] [CMD] [ARG1 [ARG2 ...]]
# Run a command inside the container. If no command is specified, the container id is printed. 
# The workdir and upperdir parameters can be used to save file system changes made inside the container.


import argparse
import atexit
import os
import sys
import tempfile
from os.path import join
from pwd import getpwuid
from subprocess import CalledProcessError, call, check_call

from plashlib.utils import catch_and_die, deescalate_sudo, die

MOUNT_IF_EXISTS_IN_HOST = ['/home', '/Users']


# def delete_line(f, func):
#     lines = f.readlines()
#     f.seek(0)
#     for line in lines:
#         if not func(line):
#             f.write(line)
#     f.truncate()

# def add_user(passwd_file, pw_entry):
#     passwd = open(join(mountpoint, 'etc/passwd'), 'r+')
#     delete_line(
#         passwd,
#         lambda line: int(line.split(':')[2]) == uid)
#     passwd_entry = '{pw_name}:x:{pw_uid}:{pw_gid}:{pw_gecos}:{pw_dir}:/bin/sh'.format(**dict(
#         (i, getattr(pw_entry, i)) for i in dir(pw_entry)))
#     passwd.write(passwd_entry + '\n')
#     passwd.close()


workdir = None
upperdir = None
deescalate = True
try:
    container, *cmd = sys.argv[1:]
    while True:
        if not cmd:
            break
        if cmd[0] == '--workdir':
            cmd.pop(0)
            workir = cmd.pop(0)
        elif cmd[0] == '--upperdir':
            cmd.pop(0)
            upperdir = cmd.pop(0)
        elif cmd[0] == '--dont-deescalate':
            cmd.pop(0)
            deescalate = False
        elif cmd[0] == '--':
            cmd.pop(0)
            break
        else:
            break
    if container.startswith('-') or cmd and cmd[0].startswith('-'):
        raise ValueError()
except (IndexError, ValueError):
    print(
        'USAGE: run container [--workdir value] [--upperdir value] cmd1 [cmd2 [cmd3 ...]]',
        file=sys.stderr)
    sys.exit(2)

mountpoint = tempfile.mkdtemp(dir='/var/tmp')
exit = call(['plash.mount', container, mountpoint] + ([
    '--workdir', workdir
] if workdir else []) + (['--upperdir', upperdir] if upperdir else []))
if exit:
    sys.exit(exit)

# write a /plashenv file
with open(join(mountpoint, 'plashenv'), 'w') as f:
    f.write(container + '\n')

uid = int(os.environ.get('SUDO_UID') or os.getuid())

# pw_entry = getpwuid(uid)
# home = pw_entry.pw_dir
# add_user(join(mountpoint, '/etc/passwd'), pw_entry)


mounts = ['proc', 'sys', 'dev', 'tmp', 'etc/resolv.conf']
mounts_map = dict((m, join(mountpoint, m.lstrip('/'))) for m in mounts)

for m in MOUNT_IF_EXISTS_IN_HOST:
    if os.path.exists(m):
        mounts_map[m] = join(mountpoint, m.lstrip('/'))
        try:
            os.makedirs(mounts_map[m]) # FIXME: directory access rights, maybe
        except FileExistsError:
            pass
        with catch_and_die([CalledProcessError]):
            check_call(['mount', '--bind', m, mounts_map[m]])

with catch_and_die([CalledProcessError]):

    # for m in EXTRA_MOUNTS_IF_EXISTS:
    #     if os.path.exists(join(mountpoint, m.lstrip('/'))):
    #         mounts.append(m)

    # prepare mounts for container
    # check_call(['mount', '--bind', home, mounts_map[home]])
    check_call(['mount', '-t', 'proc', 'proc', mounts_map['proc']])
    check_call(['mount', '--bind', '/sys', mounts_map['sys']])
    check_call(['mount', '--bind', '/dev', mounts_map['dev']])
    check_call(['mount', '--bind', '/tmp', mounts_map['tmp']])
    check_call([
        'mount', '--bind', '/etc/resolv.conf',
        mounts_map['etc/resolv.conf']
    ])

if not os.fork():
    pwd = os.getcwd()
    os.chroot(mountpoint)

    pwnetry = getpwuid(0)
    default_root_shell = pwnetry.pw_shell
    if not cmd:
        cmd = [default_root_shell]

    os.chmod('/', 0o755) # not so sure if this here or more to the top
    if deescalate:
        deescalate_sudo()
    try:
        os.chdir(pwd)
    except (ValueError, PermissionError, FileNotFoundError): # TODO: put more exceptions here
        os.chdir("/")
    try:
        os.execvpe(cmd[0], cmd, os.environ)
    except FileNotFoundError:
        die('Command not found: {}'.format(cmd[0]))
_, exit = os.wait()

with catch_and_die([CalledProcessError]):
    for mp in mounts_map.values():
        check_call(['umount', '-l', mp])
    check_call(['umount', '-l', mountpoint])

sys.exit(exit // 256)
