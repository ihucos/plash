#!/usr/bin/env python3
#
# usage: plash-build-shell CONTAINER
# Reads a shell script from stdin and returns a builded or cached container on top of the supplied container.
# The new container is the only thing printed to stdout, building information and status messages are printed to stderr.
# For most cases use `plash build` for a higher level interface.
#
# Exit status:
# Same as `plash build`


import atexit
import errno
import os
import shutil
import subprocess
import sys
from os.path import basename, join
from subprocess import (DEVNULL, CalledProcessError, Popen, check_call,
                        check_output)
from sys import exit
from tempfile import mkdtemp

from plashlib.utils import catch_and_die, color, die, hashstr, info, nodepath_or_die, die_with_usage, handle_help_flag, handle_build_args


PLASH_DATA = os.environ.get('PLASH_DATA', '/var/lib/plash')

handle_help_flag()
handle_build_args()

try:
    container = sys.argv[1]
except IndexError:
    die_with_usage()

nodepath = nodepath_or_die(container)

new_container = hashstr(os.urandom(100))[:12]
final_child_dst = join(
    join(PLASH_DATA, 'builds'), nodepath, 'children', new_container)

linkname = join(PLASH_DATA, 'links', new_container)
with catch_and_die([OSError], debug='symlink'):
    os.symlink(final_child_dst, linkname)

new_child = mkdtemp(dir=join(PLASH_DATA, 'tmp'))
workdir = mkdtemp(dir=join(PLASH_DATA, 'tmp'))
mountpoint = mkdtemp(dir=join(PLASH_DATA, 'tmp'))
new_layer = join(new_child, 'payload')
os.mkdir(new_layer)
os.mkdir(join(new_child, 'children'))

with catch_and_die([CalledProcessError]):
    subprocess.check_call(
        ['plash-run', container, '--dont-deescalate', '--upperdir', new_layer, '--workdir', workdir, 'sh'],
        env=os.environ,
        cwd='/')

with catch_and_die(OSError):
    os.rename(new_child, final_child_dst)

print(new_container)
