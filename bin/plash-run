#!/usr/bin/env python3
#
# usage: plash-run CONTAINER [--upperdir-workdir-pair WORKDIR UPPERDIR] [--mount MOUNTS] [--deescalate-sudo] [CMD1 [CMD2 [CMD3 ...]]
# Run a command inside a container. If no command is specified a shell is started.
# The workdir and upperdir parameters can be used to save file system changes made inside the container.

import os
import sys

if os.getuid() != 0:
    os.execlp('/home/irae/plash/bin/plash-run-suid', '/home/irae/plash/bin/plash-run-suid', *sys.argv[1:])

# suid wrapper stuff
os.environ['PATH'] = '/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
try:
    os.setreuid(0, 0)
except PermissionError:
    # call the suid wrapper
    os.execl(
        '/usr/local/bin/plash-run-wrapper',
        '/usr/local/bin/plash-run-wrapper',
        *sys.argv[1:])

import argparse
from time import sleep
import atexit
import tempfile
import signal
from os.path import join, isdir
from shutil import rmtree
from subprocess import CalledProcessError, call, check_call

from plashlib.utils import catch_and_die, deescalate_sudo, die, die_with_usage, handle_help_flag, handle_build_args, get_default_shell
from plashlib import ux

PLASH_TMP = join(os.environ.get('PLASH_DATA', '/var/lib/plash'), 'tmp')
MOUNTPOINT_DIR = '/var/tmp/'
DEFAULT_MOUNTS = ['default']

# SECURITY: noexec and so on in / mounts?
PSEUDO_FSTAB = '''
proc ./proc proc rw,nosuid,nodev,noexec,relatime
devtmpfs ./dev devtmpfs rw,relatime,size=498860k,nr_inodes=124715,mode=755
sysfs ./sys sysfs rw,nosuid,nodev,noexec,relatime
tmpfs ./dev/shm tmpfs rw,nosuid,nodev
devpts ./dev/pts devpts rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000
tmpfs ./run tmpfs rw,nosuid,nodev,mode=755
tmpfs ./run/lock tmpfs rw,nosuid,nodev,noexec,relatime,size=5120k
tmpfs ./sys/fs/cgroup tmpfs nosuid,nodev,noexec,mode=755
cgroup ./sys/fs/cgroup/pids cgroup rw,nosuid,nodev,noexec,relatime,pids
cgroup ./sys/fs/cgroup/debug cgroup rw,nosuid,nodev,noexec,relatime,debug
cgroup ./sys/fs/cgroup/cpuset cgroup rw,nosuid,nodev,noexec,relatime,cpuset
cgroup ./sys/fs/cgroup/freezer cgroup rw,nosuid,nodev,noexec,relatime,freezer
cgroup ./sys/fs/cgroup/memory cgroup rw,nosuid,nodev,noexec,relatime,memory
cgroup ./sys/fs/cgroup/rdma cgroup rw,nosuid,nodev,noexec,relatime,rdma
cgroup ./sys/fs/cgroup/perf_event cgroup rw,nosuid,nodev,noexec,relatime,perf_event
cgroup ./sys/fs/cgroup/devices cgroup rw,nosuid,nodev,noexec,relatime,devices
cgroup ./sys/fs/cgroup/net_cls,net_prio cgroup rw,nosuid,nodev,noexec,relatime,net_cls,net_prio
cgroup ./sys/fs/cgroup/blkio cgroup rw,nosuid,nodev,noexec,relatime,blkio
cgroup ./sys/fs/cgroup/cpu,cpuacct cgroup rw,nosuid,nodev,noexec,relatime,cpu,cpuacct
debugfs ./sys/kernel/debug debugfs rw,relatime
mqueue ./dev/mqueue mqueue rw,relatime
configfs ./sys/kernel/config configfs rw,relatime
fusectl ./sys/fs/fuse/connections fusectl rw,relatime
binfmt_misc ./proc/sys/fs/binfmt_misc binfmt_misc rw,relatime
/home ./home none defaults,bind
/tmp ./tmp none defaults,bind
/etc/passwd ./etc/passwd none defaults,bind
/etc/group ./etc/group none defaults,bind
/etc/hosts ./etc/hosts none defaults,bind
/etc/resolv.conf ./etc/resolv.conf none defaults,bind
'''

MOUNT_GROUPS = {
    'cgroup': [
        '/sys/fs/cgroup', '/sys/fs/cgroup/pids', '/sys/fs/cgroup/debug',
        '/sys/fs/cgroup/cpuset', '/sys/fs/cgroup/freezer',
        '/sys/fs/cgroup/memory', '/sys/fs/cgroup/rdma',
        '/sys/fs/cgroup/perf_event', '/sys/fs/cgroup/devices',
        '/sys/fs/cgroup/net_cls,net_prio', '/sys/fs/cgroup/blkio',
        '/sys/fs/cgroup/cpu,cpuacct'
    ],
    'debugfs': ['/sys/kernel/debug'],
    'mqueue': ['/dev/mqueue'],
    'configfs': ['/sys/kernel/config'],
    'fusectl': ['/sys/fs/fuse/connections'],
    'binfmt_misc': ['/proc/sys/fs/binfmt_misc'],
    'default': ['/proc', '/etc/resolv.conf', '/home', '/tmp'],
    'host': ['/tmp', '/home'],
}

handle_help_flag()
handle_build_args()
ux.assert_initialized()

main_pid = os.getpid()


def expand_mount_groups(arg_parts):
    for i in arg_parts:
        if i.startswith('/'):
            yield i
        else:
            try:
                for a in MOUNT_GROUPS[i]:
                    yield a
            except KeyError:
                die('invalid mount group {}, available: {}'.format(
                    repr(i), ' '.join(MOUNT_GROUPS.keys())))


def start_cleanup_daemon():
    '''
    Start a child process to cleanup when its parent dies
    '''
    if not os.fork():
        os.close(0)
        os.close(
            1
        )  # really weird, we need to close stdout or another process calling this via check_output will block forever
        os.close(2)
        out = open('/var/log/plash-run-cleanup.log', 'a+')
        os.dup2(out.fileno(), 1)
        os.dup2(out.fileno(), 2)

        os.setsid(
        )  # makes this is kind of a standalone "daemon" process, not more inherit the signal processing
        os.chdir('/')  # don't lock the directory we where started
        # os.setpgrp()  # that fixes that the called process waits for all its childs to finish
        # fork and exit so the child gets 1 as the parent id, which solves blocking if the main process exec waits for its children.
        signal.signal(signal.SIGHUP, signal.SIG_IGN
                      )  # don't die if the user closes the terminal (untested)
        if os.fork():
            sys.exit(0)
        else:
            while True:
                sleep(1)
                parent_dead = not isdir(join('/proc', str(main_pid)))
                if parent_dead:

                    # cleanup
                    for mp in reversed(requested_mounts):  # unmount reversed
                        try:
                            check_call(['umount', join(mountpoint, mp[1:])])
                        except CalledProcessError as exc:
                            print(exc)
                    check_call(['umount', mountpoint])
                    for dir in clean_dirs:
                        rmtree(dir)
                    sys.exit(0)


#
# parse arguments
#
workdir = None
upperdir = None
requested_mounts = list(expand_mount_groups(DEFAULT_MOUNTS))
deescalate = False
try:
    container, *args = sys.argv[1:]
    while args:
        cmd = args.pop(0)
        if cmd == '--':
            break
        if not cmd.startswith('-'):
            args.insert(0, cmd)
            break
        if cmd == '--upperdir-workdir-pair':
            upperdir, workdir = args.pop(0), args.pop(0)
        elif cmd in ('--mount', '-m'):
            parts = args.pop(0).split(',')
            requested_mounts = list(expand_mount_groups(parts))
        elif cmd in ('--deescalate-sudo'):
            deescalate = True
        else:
            die_with_usage(hint='unknown flag: {}'.format(cmd))
    cmd = args
except (IndexError, ValueError):
    die_with_usage()

clean_dirs = []
if not upperdir or not workdir:
    upperdir = tempfile.mkdtemp(
        dir=PLASH_TMP, prefix='upperdir-{}-'.format(main_pid))
    workdir = tempfile.mkdtemp(
        dir=PLASH_TMP, prefix='workdir-{}-'.format(main_pid))
    clean_dirs.extend([upperdir, workdir])

# fail here instead of inside plash-mount for nicer error message
ux.assert_container_exists(container)

mountpoint = tempfile.mkdtemp(
    dir=MOUNTPOINT_DIR, prefix='plash-run-{}-'.format(main_pid))

with catch_and_die([CalledProcessError]):
    check_call([
        'plash-mount', container, '--upperdir', upperdir, '--workdir', workdir,
        mountpoint
    ])

start_cleanup_daemon()

#
# mounts
#
pwd_at_start = os.getcwd()
os.chdir(mountpoint)
unused_mounts = set(requested_mounts)
for line in PSEUDO_FSTAB.splitlines():
    if not line or line.startswith('#'):
        continue
    device, dir, type, options = line.split()
    assert dir.startswith('./'), 'PSEUDO_FSTAB mountpoints must be relative'
    try:
        unused_mounts.remove(dir[1:])
    except KeyError:
        continue
    try:
        os.makedirs(dir, exist_ok=True)
    except FileExistsError:
        pass
    check_call(['mount', '-t', type, '-o', options, device, dir])
if unused_mounts:
    die('unknown mount point(s): {}'.format(' '.join(unused_mounts)))

os.chroot(mountpoint)
os.chdir('/')

if not cmd:
    default_root_shell = get_default_shell('/etc/passwd')
    cmd = [default_root_shell]

os.chmod('/', 0o755)  # not so sure if this here or more to the top
if deescalate:
    deescalate_sudo()
try:
    os.chdir(pwd_at_start)
except (ValueError, PermissionError, FileNotFoundError):  # TODO: put more exceptions here
        pass

try:
    os.execlp(cmd[0], *cmd)
except FileNotFoundError:
    die('Command not found: {}'.format(cmd[0]))
