#!/usr/bin/env python3
#
# usage: plash-run CONTAINER [--upperdir UPPERDIR --workdir WORKDIR] [--dont-deescalate] [CMD1 [CMD2 [CMD3 ...]]
# Run a command inside the container. If no command is specified a shell is started.
# The workdir and upperdir parameters can be used to save file system changes made inside the container.


import argparse
from time import sleep
import atexit
import os
import sys
import tempfile
import signal
from os.path import join, isdir
from shutil import rmtree
from subprocess import CalledProcessError, call, check_call

from plashlib.utils import catch_and_die, deescalate_sudo, die, die_with_usage, handle_help_flag

MOUNT_IF_EXISTS_IN_HOST = ['/home', '/Users']
PLASH_TMP = join(os.environ.get('PLASH_DATA', '/var/lib/plash'), 'tmp')
MOUNTPOINT_DIR = '/var/tmp/'

handle_help_flag()


def start_cleanup_daemon(mounts_map, clean_dirs):
    '''
    Start a child process to cleanup when its parent dies
    '''
    if not os.fork():
        os.close(0)
        os.close(1)  # really weird, we need to close stdout or another process calling this via check_output will block forever
        os.close(2)
        out = open('/var/log/plash-run-cleanup.log', 'a+')
        os.dup2(out.fileno(), 1)
        os.dup2(out.fileno(), 2)
    
        os.setsid()  # makes this is kind of a standalone "daemon" process, not more inherit the signal processing
        os.chdir('/')  # don't lock the directory we where started
        #os.setpgrp()  # that fixes that the called process waits for all its childs to finish
        # fork and exit so the child gets 1 as the parent id, which solves blocking if the main process exec waits for its children.
        signal.signal(signal.SIGHUP, signal.SIG_IGN)  # don't die if the user closes the terminal (untested)
        if os.fork():
           sys.exit(0)
        else:
           while True:
               sleep(5)
               parent_dead =  not isdir(join('/proc', str(main_pid)))
               if parent_dead:

                   # cleanup
                   with catch_and_die([CalledProcessError]):
                       for mp in mounts_map.values():
                              check_call(['umount', '-l', mp])
                       check_call(['umount', '-l', mountpoint])
                   for i in clean_dirs:
                       rmtree(i)
                   sys.exit(0)

workdir = None
upperdir = None
deescalate = True
try:
    container, *cmd = sys.argv[1:]
    while True:
        if not cmd:
            break
        if cmd[0] == '--workdir':
            cmd.pop(0)
            workdir = cmd.pop(0)
        elif cmd[0] == '--upperdir':
            cmd.pop(0)
            upperdir = cmd.pop(0)
        elif cmd[0] == '--dont-deescalate':
            cmd.pop(0)
            deescalate = False
        elif cmd[0] == '--':
            cmd.pop(0)
            break
        else:
            break
    if container.startswith('-') or cmd and cmd[0].startswith('-'):
        raise ValueError()
    if (not workdir and upperdir) or (workdir and not upperdir):
        raise ValueError()
except (IndexError, ValueError):
    die_with_usage()

main_pid = os.getpid()
clean_dirs = []
if not upperdir or not workdir:
    upperdir = tempfile.mkdtemp(dir=PLASH_TMP, prefix='upperdir-{}-'.format(main_pid))
    workdir = tempfile.mkdtemp(dir=PLASH_TMP, prefix='workdir-{}-'.format(main_pid))
    clean_dirs.extend([upperdir, workdir])

mountpoint = tempfile.mkdtemp(dir=MOUNTPOINT_DIR, prefix='plash-run-{}-'.format(main_pid))
clean_dirs.append(mountpoint)

exit = call([
    'plash-mount',
    container,
    mountpoint,
    '--upperdir',
    upperdir,
    '--workdir',
    workdir
])
if exit:
    sys.exit(exit)

# write a /plashenv file
with open(join(mountpoint, 'plashenv'), 'w') as f:
    f.write(container + '\n')

uid = int(os.environ.get('SUDO_UID') or os.getuid())

mounts = ['proc', 'sys', 'dev', 'tmp', 'etc/resolv.conf']
mounts_map = dict((m, join(mountpoint, m.lstrip('/'))) for m in mounts)
for m in MOUNT_IF_EXISTS_IN_HOST:
    if os.path.exists(m):
        mounts_map[m] = join(mountpoint, m.lstrip('/'))
        try:
            os.makedirs(mounts_map[m]) # FIXME: directory access rights, maybe
        except FileExistsError:
            pass
        with catch_and_die([CalledProcessError]):
            check_call(['mount', '--bind', m, mounts_map[m]])

with catch_and_die([CalledProcessError]):
    check_call(['mount', '-t', 'proc', 'proc', mounts_map['proc']])
    check_call(['mount', '--rbind', '/sys', mounts_map['sys']])
    check_call(['mount', '--bind', '/dev', mounts_map['dev']])
    check_call(['mount', '--bind', '/tmp', mounts_map['tmp']])
    check_call([
        'mount', '--bind', '/etc/resolv.conf',
        mounts_map['etc/resolv.conf']
    ])

start_cleanup_daemon(mounts_map, clean_dirs)

pwd = os.getcwd()
os.chroot(mountpoint)
os.chdir('/')

with open('/etc/passwd') as f:
    #  the first entry is the root entry
    #  https://security.stackexchange.com/questions/96241/why-require-root-to-be-the-first-entry-in-etc-passwd
    root_entry = f.readline().rstrip('\n')
    default_root_shell = root_entry.split(":")[6]
if not cmd:
    cmd = [default_root_shell]

os.chmod('/', 0o755) # not so sure if this here or more to the top
if deescalate:
    deescalate_sudo()
try:
    os.chdir(pwd)
except (ValueError, PermissionError, FileNotFoundError): # TODO: put more exceptions here
    os.chdir("/")
try:
    os.execvpe(cmd[0], cmd, os.environ)
except FileNotFoundError:
    die('Command not found: {}'.format(cmd[0]))
