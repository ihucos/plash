#!/usr/bin/env python3
#
# usage: plash import-lxc IMAGE-NAME
# Import image from linuxcontainers.org

import re
import os
import sys
from subprocess import CalledProcessError, check_call
from urllib.error import URLError
from urllib.request import urlopen

from plash.utils import (assert_initialized, catch_and_die, die,
                         die_with_usage)

LXC_URL_TEMPL = 'https://images.linuxcontainers.org/images/{}/{}/{}/{}/{}/rootfs.tar.xz'

UBUNTU_ABC = 'tuvwxyzabcdefghijklmnopqrs'  # rotate manually every decade or so


def use_current(version):
    return int(version == 'current')

def use_version_number(version):
    try:
        return tuple(int(i) for i in version.split('.'))
    except ValueError:
        return (-1,)

def use_index(order):
    order_lower = [i.lower() for i in order]
    def quantifier(version):
        try:
            return order_lower.index(version.lower())
        except ValueError:
            return -1
    return quantifier

def use_alphabet(version):
    return version

def use_ubuntu(version):
    return UBUNTU_ABC.find(version[0].lower())


FIND_NEWEST_VERSION = {
    'alpine': use_version_number,
    'archlinux': use_current,
    'centos': use_version_number,
    'debian': use_index(['jessie', 'stretch', 'buster', 'bullseye']),
    'devuan': use_alphabet,
    'fedora': use_version_number,
    'gentoo': use_current,
    'kali': use_current,
    'opensuse': use_version_number,
    'openwrt': use_current,
    'oracle': use_version_number,
    'sabayon': use_current,
    'ubuntu': use_ubuntu,
    'ubuntu-core': use_version_number,
}


DEBIAN_RELESES = [
    # well, some constant in some file to keep updated... That here should only be fine until 2022 or something
    'bullseye',
    'buster',
    'stretch',
    'jessie',
    'wheezy'
]
assert_initialized()

try:
    image_name = sys.argv[1]
except IndexError:
    die_with_usage()

with catch_and_die([URLError]):
    content = urlopen('https://images.linuxcontainers.org/').read().decode()
matches = re.findall(
    '<tr><td>(.+?)</td><td>(.+?)</td><td>(.+?)</td><td>(.+?)</td><td>(.+?)</td><td>(.+?)</td><td>(.+?)</td><td>(.+?)</td></tr>',
    content)

versions = {}
urls = {}
for distro, version, arch, variant, date, _, _, _ in matches:
    if not variant == 'default':
        continue

    if arch != 'amd64':  # only support this right now
        continue

    url = LXC_URL_TEMPL.format(distro, version, arch, variant, date)
    urls[(distro, version)] = url
    versions.setdefault(distro, [])
    versions[distro].append(version)

def die_image_not_found():
    all_images = sorted([':'.join(i) for i in urls] + list(FIND_NEWEST_VERSION.keys()))
    die('image not found ({}), but there is: {}'.format(repr(image_name),
                ' '.join(all_images)))

#from pprint import pprint
#pprint(urls)
#pprint(versions)

if not ':' in image_name:
    try:
        version_quantifier = FIND_NEWEST_VERSION[image_name]
    except KeyError:
        die_image_not_found()

    sorted_versions = sorted(versions[image_name], key=version_quantifier)
    latest_version = list(sorted_versions)[-1]
    image_key = (image_name, latest_version)
else:
    image_key = image_name.split(':')

try:
    url = urls[image_key]
except KeyError:
    die_image_not_found()

signature_url = '{}.asc'.format(url)
os.execlp('plash', 'plash', 'import-url', url, signature_url)
